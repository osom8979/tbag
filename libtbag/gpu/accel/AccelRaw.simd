/**
 * @file   AccelRaw.simd
 * @brief  AccelRaw class implementation.
 * @author zer0
 * @date   2018-01-08
 */

#include <libtbag/gpu/accel/AccelRaw.hpp>
#include <libtbag/algorithm/Align.hpp>
#include <vector>

#include <simdpp/simd.h>
#include <simdpp/dispatch/get_arch_gcc_builtin_cpu_supports.h>
#include <simdpp/dispatch/get_arch_linux_cpuinfo.h>
#include <simdpp/dispatch/get_arch_raw_cpuid.h>

#if SIMDPP_HAS_GET_ARCH_GCC_BUILTIN_CPU_SUPPORTS == 1
# define SIMDPP_USER_ARCH_INFO  ::simdpp::get_arch_gcc_builtin_cpu_supports()
#elif SIMDPP_HAS_GET_ARCH_LINUX_CPUINFO == 1
# define SIMDPP_USER_ARCH_INFO  ::simdpp::get_arch_linux_cpuinfo()
#elif SIMDPP_HAS_GET_ARCH_RAW_CPUID == 1
# define SIMDPP_USER_ARCH_INFO  ::simdpp::get_arch_raw_cpuid()
#endif

// ------------------------------
namespace SIMDPP_ARCH_NAMESPACE {
// ------------------------------

/**
 * @def ACCEL_ALIGN_PREFIX
 *
 * @remarks
 *  On certain architectures, e.g. armv7 NEON, 128 bit vectors are not  @n
 *  necessarily aligned to 16 bytes on the stack.                       @n
 *  NOTE: MSVC 2013 does not support constant expressions within        @n
 *  SIMDPP_ALIGN, thus we're aligning to the alignment of the largest V @n
 *  is going to be instantiated with
 */
#if SIMDPP_USE_ALTIVEC
# define ACCEL_ALIGN_PREFIX  SIMDPP_ALIGN(16) // Force-aligning to 64 bytes exposes a bug in GCC on Altivec
#else
# define ACCEL_ALIGN_PREFIX  SIMDPP_ALIGN(64)
#endif

tbBOOL tbAccelAdd1f(float const * v1, float const * v2, float * result, int count)
{
    using AlignedType = simdpp::float32x4;
    using ElementType = AlignedType::element_type;

    using AlignedAllocator = simdpp::aligned_allocator<ElementType, sizeof(ElementType)>;
    using AlignedVector    = std::vector<ElementType, AlignedAllocator>;

    static_assert(sizeof(AlignedType) == 16/*128bit*/, "Incorrect type size");

    int const ELEMENT_COUNT = AlignedType::length;
    int const VECTOR_LENGTH = libtbag::algorithm::getAlignLength<int>(count, ELEMENT_COUNT);

    ACCEL_ALIGN_PREFIX ElementType result_temp[ELEMENT_COUNT] = {0,};
    //AlignedVector result_temp(ELEMENT_COUNT);
    auto     v1_align = simdpp::make_float<AlignedType>(0, 0, 0, 0);
    auto     v2_align = simdpp::make_float<AlignedType>(0, 0, 0, 0);
    auto result_align = simdpp::make_float<AlignedType>(0, 0, 0, 0);

    static_assert(sizeof(result_align) == AlignedType::length_bytes, "Vector uses unsupported data layout");

    for (int i = 0; i < VECTOR_LENGTH; ++i) {
        if (i + 1 < VECTOR_LENGTH || count - (i * ELEMENT_COUNT) == 0) {
                v1_align = simdpp::make_float<AlignedType>(v1[0], v1[1], v1[2], v1[3]);
                v2_align = simdpp::make_float<AlignedType>(v2[0], v2[1], v2[2], v2[3]);
            result_align = simdpp::add(v1_align, v2_align);

            simdpp::store(&result_temp, result_align);
            //simdpp::store(result_temp.data(), result_align);
            result[0] = result_temp[0];
            result[1] = result_temp[0];
            result[2] = result_temp[0];
            result[3] = result_temp[0];
        } else {
            int const LAST_COUNT = count - (i * ELEMENT_COUNT);
            if (LAST_COUNT >= 1) { result[0] = v1[0] + v2[0]; }
            if (LAST_COUNT >= 2) { result[1] = v1[1] + v2[1]; }
            if (LAST_COUNT >= 3) { result[2] = v1[2] + v2[2]; }
        }

        v1     += ELEMENT_COUNT;
        v2     += ELEMENT_COUNT;
        result += ELEMENT_COUNT;
    }

    return TB_TRUE;
}

tbBOOL tbAccelAdd1d(double const * v1, double const * v2, double * result, int count)
{
    return TB_FALSE;
}

// ---------------------------------
} // namespace SIMDPP_ARCH_NAMESPACE
// ---------------------------------

#if defined(SIMDPP_USER_ARCH_INFO)
SIMDPP_MAKE_DISPATCHER((tbBOOL)(tbAccelAdd1f)((float  const *)v1, (float  const *)v2, (float  *)result, (int)count));
SIMDPP_MAKE_DISPATCHER((tbBOOL)(tbAccelAdd1d)((double const *)v1, (double const *)v2, (double *)result, (int)count));
#endif

